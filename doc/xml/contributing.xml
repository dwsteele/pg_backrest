<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE doc SYSTEM "doc.dtd">
<doc title="{[project]}" subtitle="Contributing to {[project]}" toc="y" cmd-line-len="132">
    <description>{[project]} Contributing Guidelines.</description>

    <!-- Variables used by the rest of the script ============================================================================== -->
    <variable-list>
        <variable key="host-user-id" eval="y">use English; $UID</variable>

        <!-- Options to pass to test.pl so log output is reproducible -->
        <variable key="test-cmd-extra">--no-log-timestamp</variable>

        <variable key="host-contrib-id">contrib</variable>
        <variable key="host-contrib">pgbackrest-dev</variable>
        <variable key="host-contrib-user">{[host-user]}</variable>
        <variable key="host-contrib-image">pgbackrest/doc:contrib</variable>

        <variable key="cwd" eval="y">use Cwd qw(cwd); cwd()</variable>
    </variable-list>

    <!-- Setup hosts used to build the documentation =========================================================================== -->
    <host-define if="{[os-type-is-debian]}" image="{[host-contrib-image]}" from="ubuntu:18.04">
        {[copy-ca-cert]}

        # Fix root tty
        RUN sed -i 's/^mesg n/tty -s \&amp;\&amp; mesg n/g' /root/.profile &amp;&amp; \

        # Suppress dpkg interactive output
            rm /etc/apt/apt.conf.d/70debconf

        # Install base packages
        RUN apt-get update &amp;&amp; \
            apt-get install -y sudo ssh curl vim 2>&amp;1

        # Add test user with sudo privileges
        RUN adduser --disabled-password --uid={[host-user-id]} --gecos "" {[host-user]} &amp;&amp; \
            echo '%{[host-user]} ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers

        WORKDIR /home/{[host-user]}

        ENTRYPOINT service ssh restart &amp;&amp; bash
    </host-define>

    <!-- ======================================================================================================================= -->
    <section id="introduction">
        <title>Introduction</title>

        <p>This documentation is intended to assist contributors to <backrest/> by outlining some basic steps and guidelines for contributing to the project.  Coding standards to follow are defined in <link url="{[github-url-master]}/CODING.md">CODING.md</link>. At a minimum, unit tests must be written and run and the documentation generated before submitting a Pull Request; see the <link section="/testing">Testing</link> section below for details.</p>
    </section>

    <!-- ======================================================================================================================= -->
    <section id="environment">
        <title>Building a Development Environment</title>

        <p>This example is based on <proper>Ubuntu 18.04</proper>, but it should work on many versions of <proper>Debian</proper> and <proper>Ubuntu</proper>.</p>

        <host-add id="{[host-contrib-id]}" name="{[host-contrib]}" user="{[host-contrib-user]}" image="{[host-contrib-image]}" os="u18" option="-v /var/run/docker.sock:/var/run/docker.sock -v {[cwd]}/test:{[cwd]}/test" mount="/home/{[host-contrib-user]}/pgbackrest:/home/{[host-contrib-user]}/pgbackrest"/>

        <execute-list host="{[host-contrib]}">
            <title>Install development tools</title>

            <execute user="root" pre="y" show="n">
                <exe-cmd>
                    apt-get update
                </exe-cmd>
            </execute>

            <execute user="root" pre="y">
                <exe-cmd>
                    apt-get install rsync git devscripts build-essential valgrind lcov autoconf
                    autoconf-archive libssl-dev zlib1g-dev libxml2-dev libpq-dev pkg-config
                    libxml-checker-perl libyaml-perl libdbd-pg-perl liblz4-dev liblz4-tool
                    zstd libzstd-dev bzip2 libbz2-dev
                </exe-cmd>
                <exe-cmd-extra>-y 2>&amp;1</exe-cmd-extra>
            </execute>

            <!-- Clean so the tests give consistent output -->
            <execute show="n">
                <exe-cmd>
                    pgbackrest/test/test.pl --clean-only
                </exe-cmd>
            </execute>
        </execute-list>

        <p>Some unit tests and all the integration test require <proper>Docker</proper>.  Running in containers allows us to simulate multiple hosts, test on different distributions and versions of <postgres/>, and use sudo without affecting the host system.</p>

        <execute-list host="{[host-contrib]}">
            <title>Install Docker</title>

            <execute pre="y">
                <exe-cmd>curl -fsSL https://get.docker.com | sudo sh</exe-cmd>
                <exe-cmd-extra>2>&amp;1</exe-cmd-extra>
            </execute>

            <execute user="root">
                <exe-cmd>
                    usermod -aG docker `whoami`
                </exe-cmd>
            </execute>

            <!-- Hack permissions on the docker socket so the local user can run commands -->
            <execute user="root" show="n">
                <exe-cmd>
                    chmod 666 /var/run/docker.sock
                </exe-cmd>
            </execute>
        </execute-list>

        <p>This clone of the <backrest/> repository is sufficient for experimentation.  For development, create a fork and clone that instead.</p>

        <execute-list host="{[host-contrib]}">
            <title>Clone <backrest/> repository</title>

            <execute skip="y">
                <exe-cmd>
                    git clone https://github.com/pgbackrest/pgbackrest.git
                </exe-cmd>
            </execute>
        </execute-list>
    </section>

    <section id="testing">
        <title>Testing</title>

        <p>A list of all possible test combinations can be viewed by running:</p>
        <code-block>
            pgbackrest/test/test.pl --dry-run
        </code-block>

        <p>While some files are automatically generated during <code>make</code>, others are generated by running the test harness as follows:</p>

        <code-block>
            pgbackrest/test/test.pl --gen-only
        </code-block>

        <p>Prior to any submission, the html version of the documentation should also be run and the output checked by viewing the generated html on the local file system under <code>pgbackrest/doc/output/html</code>. More details can be found in the <file>README.md</file> file of the <backrest/> <link url="{[github-url-master]}/doc">doc</link> directory.</p>

        <code-block>
            pgbackrest/doc/doc.pl --out=html
        </code-block>

        <admonition type="note"><code>ERROR: [028]</code> regarding cache is invalid is OK; it just means there have been changes and the documentation will be built from scratch. In this case, be patient as the build could take 20 minutes or more depending on your system.</admonition>

        <p>If using a RHEL system, the CPAN XML parser is required for running <file>test.pl</file> and <file>doc.pl</file>. Instructions for installing Docker and the XML parse can be found in the <file>README.md</file> file of the <backrest/> <link url="{[github-url-master]}/doc">doc</link> directory in the section <quote>The following is a sample CentOS/RHEL 7 configuration that can be used for building the documentation</quote>. NOTE that the <code>Install latex (for building PDF)</code> is not required since testing of the docs need only be run for HTML output.</p>

        <section id="running">
            <title>Running Tests</title>

            <p>Examples of test runs are provided in the following sections. There are several important options for running a test:</p>
            <list>
                <list-item><setting>--dry-run</setting> - without any other otpions, this will list all the available tests</list-item>
                <list-item><setting>--module</setting> - identifies the module in which the test is located</list-item>
                <list-item><setting>--test</setting> - the actual test set to be run</list-item>
                <list-item><setting>--run</setting> - a number identifying the run within a test if testing a single run rather than the entire test</list-item>
                <list-item><setting>--dev</setting> - sets several flags that are appropriate for development but should be omitted when performing final testing prior to submitting a Pull Request to the project.  Most importantly, it reuses object files from the previous test run to speed testing.</list-item>
                <list-item><setting>--vm-out</setting> - displays the test output (helpful for monitoring the progress)</list-item>
                <list-item><setting>--vm</setting> - identifies the pre-build virtual machine when using Docker, otherwise the setting should be <code>none</code></list-item>
                <list-item><setting>--coverage-only</setting> - selects a vm to use (although best when overridden with <setting>--vm=f32</setting>) and provides a coverage report in <file>test/result/coverage/coverage.html</file> or <file>test/result/coverage/lcov/index.html</file></list-item>
            </list>

            <p>For more options, run the test or documentation engine with the <setting>--help</setting> option:</p>

            <code-block>
pgbackrest/test/test.pl --help
pgbackrest/doc/doc.pl --help
            </code-block>

            <section id="without-docker">
                <title>Without Docker</title>

                <p>If <proper>Docker</proper> is not installed, then the available tests can be listed using <setting>--vm=none</setting>, and each test must then be run with <setting>--vm=none</setting>.</p>

                <execute-list host="{[host-contrib]}">
                    <title>List tests that don't require a container</title>

                    <execute output="y">
                        <exe-cmd>pgbackrest/test/test.pl --vm=none --dry-run</exe-cmd>
                        <exe-cmd-extra>{[test-cmd-extra]}</exe-cmd-extra>
                        <exe-highlight>[0-9]+ tests selected|DRY RUN COMPLETED SUCCESSFULLY</exe-highlight>
                    </execute>
                </execute-list>

                <execute-list host="{[host-contrib]}">
                    <title>Run a test</title>

                    <execute output="y">
                        <exe-cmd>pgbackrest/test/test.pl --vm=none --dev --vm-out --module=common --test=wait</exe-cmd>
                        <exe-cmd-extra>{[test-cmd-extra]}</exe-cmd-extra>
                    </execute>
                </execute-list>

                <p>An entire module can be run by using only the <setting>--module</setting> option.</p>

                <execute-list host="{[host-contrib]}">
                    <title>Run a module</title>

                    <execute output="y">
                        <exe-cmd>pgbackrest/test/test.pl --vm=none --dev --module=postgres</exe-cmd>
                        <exe-cmd-extra>{[test-cmd-extra]}</exe-cmd-extra>
                    </execute>
                </execute-list>
            </section>

            <section id="with-docker" depend="/environment">
                <title>With Docker</title>

                <p>Build a container to run tests.  The vm must be pre-configured but a variety are available. A vagrant file is provided in the test directory as an example of running in a virtual environment. The vm names are all three character abbreviations, e.g. <id>u18</id> for <proper>Ubuntu 18.04</proper>.</p>

                <execute-list host="{[host-contrib]}">
                    <title>Build a VM</title>

                    <execute output="y">
                        <exe-cmd>pgbackrest/test/test.pl --vm-build --vm=u18</exe-cmd>
                        <exe-cmd-extra>{[test-cmd-extra]}</exe-cmd-extra>
                    </execute>
                </execute-list>

                <admonition type="note">to build all the vms, just omit the <setting>--vm</setting> option above.</admonition>

                <execute-list host="{[host-contrib]}">
                    <title>Run a Specific Test Run</title>

                    <execute output="y">
                        <exe-cmd>pgbackrest/test/test.pl {[dash]}-vm=u18 {[dash]}-dev {[dash]}-module=mock {[dash]}-test=archive {[dash]}-run=2</exe-cmd>
                        <exe-cmd-extra>{[test-cmd-extra]}</exe-cmd-extra>
                    </execute>
                </execute-list>
            </section>
        </section>

        <section id="unit-test">
            <title>Writing a Unit Test</title>

            <p>The goal of unit testing is to have 100 percent code coverage. Two files will usually be involved in this process:</p>

            <list>
                <list-item><b>define.yaml</b> - defines the number of tests to be run for each module and test file. There is a comment at the top of the file that provides more information about this file.</list-item>
                <list-item><b>src/module/somefileTest.c</b> - where <quote>somefile</quote> is the path and name of the test file where the unit tests are located for the code being updated (e.g. <file>src/module/command/expireTest.c</file>).</list-item>
            </list>

            <section id="define-yaml">
                <title>define.yaml</title>

                <p>Each module is separated by a line of asterisks (*) and each test within is separated by a line of dashes (-). In the example below, the module is <code>command</code> and the unit test is <code>check</code>. The number of calls to <code>testBegin()</code> in a unit test file will dictate the number following <code>total:</code>, in this case 4. Under <code>coverage:</code>, the list of files that will be tested.</p>

                <code-block>
  # ********************************************************************************************************************************
  - name: command

    test:
      # ----------------------------------------------------------------------------------------------------------------------------
      - name: check
        total: 4
        containerReq: true

        coverage:
          - command/check/common
          - command/check/check
                </code-block>

            </section>

            <section id="test-file">
                <title>somefileTest.c</title>

                <p>Unit test files are organized in the <code>test/src/module</code> directory with the same directory structure as the source code being tested. For example, if new code is added to src/<b>command/expire</b>.c then test/src/module/<b>command/expire</b>Test.c will need to be updated.</p>

                <p>Assuming that a test file already exists, new unit tests will either go in a new <code>testBegin()</code> section or be added to an existing section. Each such section is a test run. The comment string passed to the <code>testBegin()</code> should reflect the function(s) being tested in the test run. Tests within a run should use <code>TEST_TITLE()</code> with a comment string describing the test.</p>

                <code-block>
// *****************************************************************************************************************************
if (testBegin("expireBackup()"))
{
    //--------------------------------------------------------------------------------------------------------------------------
    TEST_TITLE("manifest file removal");
                </code-block>

                <p><b>Setting up the command to be run</b></p>
                <p>The <file>test/src/common/harnessConfig.h</file> describes a list of functions that should be used when configuration options are required for a command being tested. Options are set in a <code>StringList</code> which must be defined and passed to the function <code>harnessCfgLoad()</code> with the command. For example, the following will set up a test to run <cmd>pgbackrest --repo-path=test/test-0/repo info</cmd> command:</p>

                <code-block>
StringList *argList = strLstNew();                                      // create an empty string list
hrnCfgArgRawZ(argList, cfgOptRepoPath, TEST_PATH_REPO);                 // add the --repo-path option
harnessCfgLoad(cfgCmdInfo, argList);                                    // load the command and option list into the test harness

TEST_RESULT_STR_Z(
    infoRender(), "No stanzas exist in the repository.\n", "text output - no stanzas");  // run the test
                </code-block>

                <p><b>Storing a file</b></p>
                <p>Sometimes it is desirable to store or manipulate files before or during a test and then confirm the contents. The <file>test/src/common/harnessStorage.h</file> contains macros (e.g. <code>HRN_STORAGE_PUT</code> and <code>TEST_STORAGE_GET</code>) for doing this. In addition, <code>HRN_INFO_PUT</code> is convenient for writing out info files (archive.info, backup.info, backup.manifest) since it will automatically add header and checksum information.</p>

                <code-block>
HRN_STORAGE_PUT_EMPTY(
    storageRepoWrite(), STORAGE_REPO_ARCHIVE "/10-1/000000010000000100000001-abcdabcdabcdabcdabcdabcdabcdabcdabcdabcd.gz");
                </code-block>

                <p><b>Testing results</b></p>
                <p>Tests are run and results confirmed via macros that are described in <file>test/src/common/harnessTest.h</file>. With the exception of TEST_ERROR, the third parameter is a short description of the test. Some of the more common macros are:</p>

                <list>
                    <list-item><id>TEST_RESULT_STR</id> - Test the actual value of the string returned by the function.</list-item>
                    <list-item><id>TEST_RESULT_UINT</id> / <id>TEST_RESULT_INT</id> - Test for an unsigned integer / integer.</list-item>
                    <list-item><id>TEST_RESULT_BOOL</id> - Test a boolean value.</list-item>
                    <list-item><id>TEST_RESULT_PTR</id> / <id>TEST_RESULT_PTR_NE</id> - Test a pointer: useful for testing if the pointer is <id>NULL</id> or not equal (<id>NE</id>) to <id>NULL</id>.</list-item>
                    <list-item><id>TEST_RESULT_VOID</id> - The function being tested returns a <code>void</code>. This is then usually followed by tests that ensure other actions occurred (e.g. a file was written to disk).</list-item>
                    <list-item><id>TEST_ERROR</id> / <id>TEST_ERROR_FMT</id> - Test that a specific error code was raised with specific wording.</list-item>
                </list>

                <p><b>Testing a log message</b></p>
                <p>If a function being tested logs something with <id>LOG_WARN</id>, <id>LOG_INFO</id> or other <id>LOG_</id> macro, then the logged message must be cleared before the end of the test by using the <code>harnessLogResult()</code> function.</p>

                <code-block>
harnessLogResult(
    "P00   WARN: WAL segment '000000010000000100000001' was not pushed due to error [25] and was manually skipped: error");
                </code-block>

                <p><b>Testing using child process</b></p>
                <p>Sometimes it is useful to use a child process for testing. Below is a simple example. See <file>harnessFork.h</file> for more details.</p>

                <code-block>
HARNESS_FORK_BEGIN()
{
    HARNESS_FORK_CHILD_BEGIN(0, false)
    {
        TEST_RESULT_INT_NE(
            lockAcquire(cfgOptionStr(cfgOptLockPath), strNew("stanza1"), STRDEF("999-ffffffff"), lockTypeBackup, 0, true),
            -1, "create backup/expire lock");

        sleepMSec(1000);
        lockRelease(true);
    }
    HARNESS_FORK_CHILD_END();

    HARNESS_FORK_PARENT_BEGIN()
    {
        sleepMSec(250);

        harnessCfgLoad(cfgCmdInfo, argListText);
        TEST_RESULT_STR_Z(
            infoRender(),
            "stanza: stanza1\n"
            "    status: error (no valid backups, backup/expire running)\n"
            "    cipher: none\n"
            "\n"
            "    db (current)\n"
            "        wal archive min/max (9.4): none present\n",
            "text - single stanza, no valid backups, backup/expire lock detected");

    }
    HARNESS_FORK_PARENT_END();
}
HARNESS_FORK_END();
                </code-block>

                <p><b>Testing using a shim</b></p>
                <p>A <postgres/> libpq shim is provided to simulate interactions with <postgres/>. Below is a simple example. See <file>harnessPq.h</file> for more details.</p>

                <code-block>
// Set up two standbys but no primary
harnessPqScriptSet((HarnessPq [])
{
    HRNPQ_MACRO_OPEN_GE_92(1, "dbname='postgres' port=5432", PG_VERSION_92, "/pgdata", true, NULL, NULL),
    HRNPQ_MACRO_OPEN_GE_92(8, "dbname='postgres' port=5433", PG_VERSION_92, "/pgdata", true, NULL, NULL),

    // Close the "inner" session first (8) then the outer (1)
    HRNPQ_MACRO_CLOSE(8),
    HRNPQ_MACRO_CLOSE(1),

    HRNPQ_MACRO_DONE()
});

TEST_ERROR(cmdCheck(), ConfigError, "primary database not found\nHINT: check indexed pg-path/pg-host configurations");
            </code-block>

            </section>
        </section>

        <section id="unit-test-run">
            <title>Running a Unit Test</title>

            <p><b>Code Coverage</b></p>
            <p>Unit tests are run and coverage of the code being tested is provided by running the test with the option <code>--coverage-only</code>. The following example would run the test set from the <b>define.yaml</b> section detailed above.</p>

            <code-block>
pgbackrest/test/test.pl --vm-out --dev --module=command --test=check --coverage-only
            </code-block>

<admonition type="note">If the message <code>
ERROR: [125]: function not found at line</code> is displayed after <code>INFO: writing C coverage report</code> at the end of the test then try rerunning the test with <code>--vm=f32</code></admonition>

            <p>Because no test run is specified and <code>--coverage-only</code> has been requested, a coverage report will be generated and written to the local file system under the <backrest/> directory <file>test/result/coverage/lcov/index.html</file> and a file with only the highlighted code that has not been covered will be written to <file>test/result/coverage/coverage.html</file>.

            If 100 percent code coverage has not been achieved, an error message will be displayed, for example: <code>ERROR: [125]: c module command/check/check is not fully covered</code></p>

            <p><b>Debugging with files</b></p>

            <p>Sometimes it is useful to look at files that were generated during the test. The default for running any test is that, at the start/end of the test, the test harness will clean up all files and directories created. To override this behavior, a single test run must be specified and the option <code>--no-cleanup</code> provided. Again, continuing with the check command, from <b>define.yaml</b> above, there are four tests. Below, test one will be run and nothing will be cleaned up so that the files and directories in test/test-0 can be inspected.</p>

            <code-block>
pgbackrest/test/test.pl --vm-out --dev --module=command --test=check --coverage-only --run=1 --no-cleanup
            </code-block>
        </section>
    </section>

    <section id="option">
        <title>Adding an Option</title>

        <p>Options can be added to a command or multiple commands. Options can be configuration file only, command-line only or valid for both. Once an option is successfully added, <file>config.auto.*</file>, <file>define.auto.*</file> and <file>parse.auto.*</file> files will automatically be generated by the build system.</p>

        <p> To add an option, two files need be to be modified:</p>
        <list>
            <list-item><file>src/build/config/config.yaml</file></list-item>
            <list-item><file>doc/xml/reference.xml</file></list-item>
        </list>

        <p>These files are discussed in the following sections along with how to verify the <code>help</code> command output.</p>

        <section id="config-file">
            <title>config.yaml</title>

            <p>There are detailed comment blocks above each section that explain the rules for defining commands and options. Regarding options, there are two types: 1) command line only, and 2) configuration file. With the exception of passphrases, all configuration file options can be passed on the command line. To configure an option for the configuration file, the <id>section:</id> key must be present.</p>

            <p>The <id>option:</id> section is broken into sub-sections by a simple comment divider (e.g. <code># Repository options</code>) under which the options are organized alphabetically by option name. To better explain this section, the <id>online</id> option will be used as an example:</p>

            <section id="online-ex1">
                <title>Example 1</title>
            <code-block>
  online:
    type: boolean
    default: true
    negate: y
    command:
      backup: {}
      stanza-create: {}
      stanza-upgrade: {}
    command-role:
      default: {}
            </code-block>

            </section>

            <p>Note that <id>section:</id> is not present thereby making this a command-line only option defined as follows:</p>

            <list>
                <list-item><id>online</id> - the name of the option</list-item>
                <list-item><id>type</id> - the type of the option. Valid values for types are: <id>boolean</id>, <id>hash</id>, <id>integer</id>, <id>list</id>, <id>path</id>, <id>size</id>, <id>string</id>, and <id>time</id>
                </list-item>
                <list-item><id>negate</id> - being a command-line only boolean option, this rule would automatically default to false so it must be defined if the option is negatable. Ask yourself if negation makes sense, for example, would a --dry-run option make sense as --no-dry-run? If the answer is no, then this rule can be omitted as it would automatically default to false. Any boolean option that cannot be negatable, must be a command-line only and not a configuration file option as all configuration boolean options must be negatable.</list-item>
                <list-item><id>default</id> - sets a default for the option if the option is not provided when the command is run. The default can be global or it can be specified for a specific command in the <id>command</id> section. However, boolean values always require a default, so if it were desirable for the default to be <code>false</code> for the <id>stanza-create</id> command then it would be coded as in the <link section="/option/config-file/online-ex2">Example 2</link> below.
                </list-item>
                <list-item><id>command</id> - list each command for which the option is valid. If a command is not listed, then the option is not valid for the command and an error will be thrown if it is attempted to be used for that command.</list-item>
            </list>

            <section id="online-ex2">
                <title>Example 2</title>
                <code-block>
  online:
    type: boolean
    default: true
    command:
      backup:
        negate: y
      stanza-create:
        negate: n
      stanza-upgrade:
        negate: y
    command-role:
      default: {}
                </code-block>

            </section>

            <p>At compile time, the config.auto.h file will be generated to create the constants used in the code for the options. For the C code, any dashes in the option name will be removed, camel-cased and prefixed with <code>cfgOpt</code>, e.g. <code>repo-path</code> becomes <code>cfgOptRepoPath</code>.</p>

        </section>

        <section id="reference-file">
            <title>reference.xml</title>

            <p>All options must be documented or the system will error during the build.  To add an option, find the command section identified by <code>command id="COMMAND"</code> section where <id>COMMAND</id> is the name of the command (e.g. <cmd>expire</cmd>) or, if the option is used by more than one command and the definition for the option is the same for all of the commands, the <code>operation-general title="General Options"</code> section.</p>

            <p>To add an option, add the following to the <code>&lt;option-list&gt;</code> section; if it does not exist, then wrap the following in <code>&lt;option-list&gt;</code> <code>&lt;/option-list&gt;</code>. This example uses the boolean option <code>force</code> of the <cmd>restore</cmd> command. Simply replace that with your new option and the appropriate <code>summary</code>, <code>text</code> and <code>example</code>.</p>

            <code-block>
&lt;option id="force" name="Force"&gt;
    &lt;summary&gt;Force a restore.&lt;/summary&gt;

    &lt;text&gt;By itself this option forces the &lt;postgres/&gt; data and tablespace paths to be completely overwritten.  In combination with &lt;br-option&gt;--delta&lt;/br-option&gt; a timestamp/size delta will be performed instead of using checksums.&lt;/text&gt;

    &lt;example>y&lt;/example&gt;
&lt;/option&gt;
            </code-block>
            <admonition type="important">currently a period (.) is required to end the <code>summary</code> section.</admonition>
        </section>

        <section id="help-test">
            <title>Testing the help</title>
tell them to run the help unit test if they have added an option to ensure - otherwise will blow up in ci
            <!-- CSHANG put something about running and updating the help -->
<!-- CSHANG!!! NEED TO UPDATE README TO LINK TO THIS AND MOVE THAT TEXT TO BEGINNING OF DOC -->
            pgbackrest/test/test.pl --vm=none --build-only
            -- this just builds the executeable - this is generally a handy thing to do to test with the binary
            then can do:
            test/bin/none/pgbackrest help backup repo-type

        </section>

        <section id="doc-test">
            <title>Testing with generated docker containers</title>
link to general builds section on readme.doc
also run with no-exe to see locally just the text
            <!-- CSHANG should we say something about generating the docs so can exec into docker containers to test? We could update the README in the doc folder... -->
            /pgbackrest/doc/doc.pl --out=html --include=user-guide --require=/quickstart --var=encrypt=n --no-cache

        </section>
    </section>
</doc>
